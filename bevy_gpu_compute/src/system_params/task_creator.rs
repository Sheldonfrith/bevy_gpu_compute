use bevy::{
    ecs::system::SystemParam,
    prelude::{Commands, Entity, Res},
    render::renderer::RenderDevice,
};
use bevy_gpu_compute_core::{
    MaxOutputLengths, TypesSpec,
    wgsl::shader_module::user_defined_portion::WgslShaderModuleUserPortion,
};

use crate::{prelude::IterationSpace, task::lib::BevyGpuComputeTask};

#[derive(SystemParam)]

pub struct BevyGpuComputeTaskCreator<'w, 's> {
    commands: Commands<'w, 's>,
    render_device: Res<'w, RenderDevice>,
}

impl BevyGpuComputeTaskCreator<'_, '_> {
    /**
     Spawns all components needed for the task to run.
     ## Generic Parameters
     You MUST pass in the types generated by the `wgsl_shader_module` attribute (proc macro) like so: ` create_task_from_rust_shader::<my_shader_module::Types>(...)` assuming your shader module looks like this:
    ```ignore
    #[wgsl_shader_module]
    mod my_shader_module
    {
    //...shader module code here
    }
    ```


     ## Parameters
     - `name` : used for future lookup and debug messages. *You must ensure it is unique.*


     - `wgsl_shader_module` : Produced by the `wgsl_shader_module` attribute (proc macro). Pass it in like this: `my_shader_module::parsed()`, if you have this in your code:
     ```ignore
     #[wgsl_shader_module]
     mod my_shader_module
     {
     //...shader module code here
     }
     ```````
    */
    pub fn create_task_from_rust_shader<ShaderModuleTypes: TypesSpec>(
        &mut self,
        name: &str,
        wgsl_shader_module: WgslShaderModuleUserPortion,
        iteration_space: IterationSpace,
        max_output_vector_lengths: MaxOutputLengths,
    ) -> Entity {
        let task = BevyGpuComputeTask::from_shader::<ShaderModuleTypes>(
            name,
            &self.render_device,
            wgsl_shader_module,
            iteration_space,
            max_output_vector_lengths,
        );
        self.commands.spawn(task).id()
    }
}
